name: numeric-prelude
version: 0.4.2
id: numeric-prelude-0.4.2-C00Q6i9BVbU28gKYwuyOJ9
key: numeric-prelude-0.4.2-C00Q6i9BVbU28gKYwuyOJ9
license: BSD3
maintainer: Henning Thielemann <numericprelude@henning-thielemann.de>
stability: Experimental
homepage: http://www.haskell.org/haskellwiki/Numeric_Prelude
synopsis: An experimental alternative hierarchy of numeric type classes
description:
    Revisiting the Numeric Classes
    .
    The Prelude for Haskell 98 offers a well-considered set of numeric classes
    which covers the standard numeric types
    ('Integer', 'Int', 'Rational', 'Float', 'Double', 'Complex') quite well.
    But they offer limited extensibility and have a few other flaws.
    In this proposal we will revisit these classes, addressing the following concerns:
    .
    [1] The current Prelude defines no semantics for the fundamental operations.
    For instance, presumably addition should be associative
    (or come as close as feasible),
    but this is not mentioned anywhere.
    .
    [2] There are some superfluous superclasses.
    For instance, 'Eq' and 'Show' are superclasses of 'Num'.
    Consider the data type
    @   data IntegerFunction a = IF (a -> Integer) @
    One can reasonably define all the methods of 'Algebra.Ring.C' for
    @IntegerFunction a@ (satisfying good semantics),
    but it is impossible to define non-bottom instances of 'Eq' and 'Show'.
    In general, superclass relationship should indicate
    some semantic connection between the two classes.
    .
    [3] In a few cases, there is a mix of semantic operations and
    representation-specific operations.
    'toInteger', 'toRational',
    and the various operations in 'RealFloating' ('decodeFloat', ...)
    are the main examples.
    .
    [4] In some cases, the hierarchy is not finely-grained enough:
    Operations that are often defined independently are lumped together.
    For instance, in a financial application one might want a type \"Dollar\",
    or in a graphics application one might want a type \"Vector\".
    It is reasonable to add two Vectors or Dollars,
    but not, in general, reasonable to multiply them.
    But the programmer is currently forced to define a method for '(*)'
    when she defines a method for '(+)'.
    .
    In specifying the semantics of type classes,
    I will state laws as follows:
    .
    >    (a + b) + c === a + (b + c)
    .
    The intended meaning is extensional equality:
    The rest of the program should behave in the same way
    if one side is replaced with the other.
    Unfortunately, the laws are frequently violated by standard instances;
    the law above, for instance, fails for 'Float':
    .
    >    (1e20 + (-1e20)) + 1.0  = 1.0
    >     1e20 + ((-1e20) + 1.0) = 0.0
    .
    For inexact number types like floating point types,
    thus these laws should be interpreted as guidelines rather than absolute rules.
    In particular, the compiler is not allowed to use them for optimization.
    Unless stated otherwise, default definitions should also be taken as laws.
    .
    Thanks to Brian Boutel, Joe English, William Lee Irwin II, Marcin
    Kowalczyk, Ketil Malde, Tom Schrijvers, Ken Shan, and Henning
    Thielemann for helpful comments.
    .
    .
    Usage:
    .
    Write modules in the following style:
    .
    > [-# LANGUAGE NoImplicitPrelude #-]
    > module MyModule where
    >
    > ... various specific imports ...
    >
    > import NumericPrelude
    .
    Importing @NumericPrelude@ is almost the same as
    .
    > import NumericPrelude.Numeric
    > import NumericPrelude.Base   .
    .
    Instead of the @NoImplicitPrelude@ pragma
    you could also write @import Prelude ()@
    but this will yield problems with numeric literals.
    .
    There are two wrapper types that allow types
    to be used with both Haskell98 and NumericPrelude type classes
    that are initially implemented for only one of them.
    .
    .
    Scope & Limitations\/TODO:
    .
    * It might be desireable to split Ord up into Poset and Ord
    (a total ordering).
    This is not addressed here.
    .
    * In some cases, this hierarchy may not yet be fine-grained enough.
    For instance, time spans (\"5 minutes\") can be added to times (\"12:34\"),
    but two times are not addable. (\"12:34 + 8:23\")
    As it stands,
    users have to use a different operator for adding time spans to times
    than for adding two time spans.
    Similar issues arise for vector space et al.
    This is a consciously-made tradeoff, but might be changed.
    This becomes most serious when dealing with quantities with units
    like @length\/distance^2@, for which @(*)@ as defined here is useless.
    (One way to see the issue: should
    @  f x y = iterate (x *) y  @
    have principal type
    @  (Ring.C a) => a -> a -> [a]  @
    or something like
    @  (Ring.C a, Module a b) => a -> b -> [b]  @
    ?)
    .
    * I stuck with the Haskell 98 names.
    In some cases I find them lacking.
    Neglecting backwards compatibility, we have renamed classes as follows:
    Num           --> Additive, Ring, Absolute
    Integral      --> ToInteger, IntegralDomain, RealIntegral
    Fractional    --> Field
    Floating      --> Algebraic, Transcendental
    Real          --> ToRational
    RealFrac      --> RealRing, RealField
    RealFloat     --> RealTranscendental
    .
    .
    Additional standard libraries might include Enum, IEEEFloat (including
    the bulk of the functions in Haskell 98's RealFloat class),
    VectorSpace, Ratio, and Lattice.
category: Math
author: Dylan Thurston <dpt@math.harvard.edu>, Henning Thielemann <numericprelude@henning-thielemann.de>, Mikael Johansson
exposed: True
exposed-modules:
    Algebra.Absolute Algebra.Additive Algebra.Algebraic
    Algebra.Differential Algebra.DimensionTerm Algebra.DivisibleSpace
    Algebra.Field Algebra.FloatingPoint Algebra.Indexable
    Algebra.IntegralDomain Algebra.NonNegative Algebra.Lattice
    Algebra.Laws Algebra.Module Algebra.ModuleBasis Algebra.Monoid
    Algebra.NormedSpace.Euclidean Algebra.NormedSpace.Maximum
    Algebra.NormedSpace.Sum Algebra.OccasionallyScalar
    Algebra.PrincipalIdealDomain Algebra.RealField Algebra.RealIntegral
    Algebra.RealRing Algebra.RealTranscendental Algebra.RightModule
    Algebra.Ring Algebra.ToInteger Algebra.ToRational
    Algebra.Transcendental Algebra.Units Algebra.Vector
    Algebra.VectorSpace Algebra.ZeroTestable MathObj.Algebra
    MathObj.DiscreteMap MathObj.LaurentPolynomial MathObj.Matrix
    MathObj.Monoid MathObj.PartialFraction MathObj.Permutation
    MathObj.Permutation.CycleList MathObj.Permutation.CycleList.Check
    MathObj.Permutation.Table MathObj.Polynomial
    MathObj.Polynomial.Core MathObj.PowerSeries
    MathObj.PowerSeries.Core MathObj.PowerSeries.DifferentialEquation
    MathObj.PowerSeries.Example MathObj.PowerSeries.Mean
    MathObj.PowerSeries2 MathObj.PowerSeries2.Core MathObj.PowerSum
    MathObj.RefinementMask2 MathObj.RootSet MathObj.Wrapper.Haskell98
    MathObj.Wrapper.NumericPrelude Number.Complex Number.DimensionTerm
    Number.DimensionTerm.SI Number.FixedPoint Number.FixedPoint.Check
    Number.GaloisField2p32m5 Number.NonNegative
    Number.NonNegativeChunky Number.PartiallyTranscendental
    Number.Peano Number.Positional Number.Positional.Check
    Number.Quaternion Number.Ratio Number.ResidueClass
    Number.ResidueClass.Check Number.ResidueClass.Maybe
    Number.ResidueClass.Func Number.ResidueClass.Reader Number.Root
    Number.OccasionallyScalarExpression Number.SI.Unit Number.SI
    Number.Physical.Unit Number.Physical.UnitDatabase Number.Physical
    Number.Physical.Read Number.Physical.Show
    NumericPrelude.List.Checked NumericPrelude.List.Generic
    NumericPrelude.Elementwise NumericPrelude.Numeric
    NumericPrelude.Base NumericPrelude
hidden-modules: NumericPrelude.List Algebra.AffineSpace
                Algebra.RealRing98 Algebra.EqualityDecision Algebra.OrderDecision
abi: 1a2ff83ff9c1c77ef5bd9d13e71c454a
trusted: False
import-dirs: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/lib/x86_64-linux-ghc-8.0.2/numeric-prelude-0.4.2-C00Q6i9BVbU28gKYwuyOJ9
library-dirs: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/lib/x86_64-linux-ghc-8.0.2/numeric-prelude-0.4.2-C00Q6i9BVbU28gKYwuyOJ9
dynamic-library-dirs: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/lib/x86_64-linux-ghc-8.0.2
data-dir: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/share/x86_64-linux-ghc-8.0.2/numeric-prelude-0.4.2
hs-libraries: HSnumeric-prelude-0.4.2-C00Q6i9BVbU28gKYwuyOJ9
depends:
    QuickCheck-2.9.2-Jyj4gc4JxkEIgGFLAsGhs9 array-0.5.1.1 base-4.9.1.0
    containers-0.5.7.1 deepseq-1.4.2.0
    non-negative-0.1.1-GXOUCBN2NiQIdS8txkW9eb
    parsec-3.1.11-113irVHGgd88sRnywByDNw
    random-1.1-9tceXaeYIMZ4JrKq20Egog
    storable-record-0.0.3.1-ItZtoVhInjCK54XumJjnAY
    utility-ht-0.0.12-Fnn9WgGbiem6G1X7619o8t
haddock-interfaces: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/doc/numeric-prelude-0.4.2/numeric-prelude.haddock
haddock-html: /home/thomas/research_alli/improv/.stack-work/install/x86_64-linux/lts-8.5/8.0.2/doc/numeric-prelude-0.4.2
