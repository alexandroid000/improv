\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{framed}
\usepackage{color}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[MOCO '18]{ACM Woodstock conference}{July 1997}{El
  Paso, Texas USA}
\acmYear{2018}
\copyrightyear{2018}


\acmArticle{4}
\acmPrice{15.00}


\begin{document}

\title{Improv: Live Coding for Robot Motion Design}


\author{Alexandra Q. Nilles}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Computer Science Department \\ University of Illinois at
Urbana-Champaign}
}
\email{nilles2@illinois.edu}

\author{Chase Gladish}
\affiliation{%
  \institution{Computer Science Department \\ University of Illinois at
Urbana-Champaign}
}
\email{webmaster@marysville-ohio.com}

\author{Mattox Beckman}
\affiliation{%
  \institution{Computer Science Department \\ University of Illinois at
Urbana-Champaign}
}
\email{larst@affiliation.org}

\author{Amy LaViers}
\affiliation{%
  \institution{Mechanical Science and Engineering Department \\ University of Illinois at
Urbana-Champaign}
}

% The default list of authors is too long for headers.
\renewcommand{\shortauthors}{A. Nilles et al.}

\begin{abstract}
This paper introduces the Improv system, a programming language for high-level
description of robot motion with immediate visualization of the
resulting motion on a physical or simulated robot. The intended users of this
tool are anyone looking to quickly generate robot motion, such as educators,
artists, and researchers. The system includes a domain-specific language,
inspired by choreographic techniques, which allows for several ways of composing
and transforming movements such as reversing movements in space and time and
changing their relative timing. Instructions in the Improv programming language
are then executed with roshask, a Haskell client for ROS ("Robot Operating
System"). ROS is an open-source robot software framework which is widely used in
academia and industry, and integrated with many commercially available robots.
However, the ROS interface can be difficult to learn, especially for people
without technical training. This paper presents a "live coding" interface for
ROS compatible with any text editor, by executing whenever the user saves
changes. Currently, Improv can be used to control any robot compatible with the
`Twist` ROS message type (which sets linear and rotational velocity). This paper
presents Improv implementations with the two-dimensional simulator
Turtlesim, as well as three-dimensional TurtleBots in the Gazebo simulation
engine.
\end{abstract}


%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%

\keywords{robotics, choreography, live coding, ROS, Haskell, roshask, HRI}


\maketitle


\section{Introduction}\label{introduction}

Robotic technology is becoming more commonly integrated into settings outside of
the factory - including classrooms {\color{red} cite lego mindstorms, first 
robotics} and art installations {\color{red} cite dancing robot works}. There
is also an increasing need for robotic technology in research labs and
workplaces that
focus less on the low-level control and programming of robots, and more on how
humans react to robot motion, or on having the robots do simple motions. All of
these applications would benefit from a method of programming robots that is
faster and more high-level than the current workflow.


Currently, many commercially available robots are programmed through proprietary
APIs, which may include demonstration-based programming of robot motion
{\color{red} cite baxter/rethink}, or through ROS (the "Robot Operating System,"
a middleware and collection of libraries which manages message passing between
the many components of robot systems {\color{red} cite ROS}). However, this
workflow has two obstacles that often make robot programming difficult,
especially for newcomers to the field. First, the programming languages used are
often at a low level of abstraction, which forces users to translate their
mental model of the movement they want the robot to perform, often introducing
mistakes and frustration. Second, the process of writing code, compiling and
executing the instructions on the robot platform can be time-intensive and
requires the user to switch between several different software modalities (text
editor, to command line, to simulation software or hardware platform).

The tool introduced in this paper, \emph{Improv}, addresses both of these
problems. To address the first (mismatch between the problem and
program domains), we introduce a small domain-specific programming language
which includes a few motion primitives and several operators which allow
movements to be combined and transformed, in space and time. The transformations
are inspired by choregraphic techniques {\color{red} cite Catie?}. 

For example, the following code, written with the ROS python API, will cause a
mobile robot, such as a Roomba or Turtlebot, to follow a path that curves
forward to the left:

\begin{verbatim}
if __name__ == '__main__':
    pub = rospy.Publisher('turtle1/cmd_vel',Twist)
    rospy.init_node('publisher_node')
    loop_rate = rospy.Rate(5)
    while not rospy.is_shutdown():
        vel=Twist()
        vel.linear.x = 1.0
        vel.angular.z = 1.0
        pub.publish(vel)
        loop_rate.sleep()
\end{verbatim}

while the equivalent code in \emph{Improv} is

\begin{verbatim}
r1 $ forward || left
\end{verbatim}

where $||$ is an operator which combines movements in parallel.

To address the second obstacle to robot programming, the length and difficulty
of the process to evaluate code on a robot, we introduce a "live coding"
infrastructure: when changes to the program file are saved, the process of
interpreting code and converting high-level commands to low-level ROS messages
is done automatically and the user can observe the effects on the simulated or
physical robot nearly immediately.

By addressing these two shortcomings of current robot programming tools, we hope
to make robotics more accessible and usable for a broader range of people,
beyond expert roboticists. Possible users of this tool include
artists, educators, newcomers to robotics, and anyone who wishes to quickly
prototype robot motion patterns.

\subsection{Related Work}

We are aware of two other projects addressing the problem of the complex
development cycle in ROS by creating tools for interactive or ``live''
programming. One such project \cite{python_live_DSLRob} created a DSL in Python
which allows for wrapping and modifying existing ROS nodes, using the Python
REPL. However, by using the Python REPL, the user is only able to experiment
with commands in a shell and is not able to save the commands they have tried in
a file. Additionally, since the DSL is implemented as a library in Python, it
inherits some of the opaque syntax of the Python ROS client. Improv has a
simpler, albeit less powerful, programming language and models movement
explicitly. Another closely related work to \emph{Improv} is the Live Robot
Programming (LRP) language \cite{campusano2017live} and its integration with PhaROS
\cite{estefo2014towards}, a client library for ROS written is Pharo, a dynamic
programming language specialized for live updating and hot recompilation. This
project allows for live-coding of ROS nodes and reconfiguration of the ROS
network with a much shorter development cycle than traditional ROS programming.
However, the aims of these projects and Improv are slightly different - the DSL,
while more high-level than most robot programming languages, was not designed
around modelling movement itself and instead model state machines that
transition on events. Thus, both of these related projects are better suited for
applications which involve reactivity and sensing of the environment, while
Improv is better suited to applications where the user wishes to quickly
generate certain movements and creatively explore movement patterns and
transformations. We also have designed the Improv language with accessibility
and ease-of-use in mind, especially for inexperienced programmers, and future
work will focus on testing and measuring the usability of the system in user
studies.

Another closely related project is \emph{Improv} is \emph{Dance}, a
domain-specific language built in Haskell \cite{Dance2003}. The project included
a DSL inspired by Labanotation, as well as a reactive layer that allowed
the robot to respond to sensor events. The project targeted humanoid
robots, while \emph{Improv} has so far targeted mobile robots, and
\emph{Dance} would generate the necessary 3D simulation code, though did
not include the live-coding interface of this work and predates ROS.
\emph{Improv} has incorporated and adapted some of the data structures
from \emph{Dance}, namely the \texttt{Action} and \texttt{Dance} data
types.

This work is also influenced by live coding interfaces and programming languages
for generating music, often part of the \emph{Algorave} performance movement
\cite{collins2014algorave}. In particular, the programming language TidalCycles
\cite{mclean2010tidal} has had a strong influence on this work, both
syntactically and in how relative timing of events is managed.

\emph{Al Jazari} is a live-coding installation which uses a simple graphical
language to allow people to control robots (in simulation)
\cite{mclean2010visualisation}. The language includes conditionals based on
external state and communication between the bots. The program state of the
robot is also visualized.

Especially when used with the two-dimensional Turtlesim, \emph{Improv}
is reminiscent of \emph{Logo} \cite{logo}, an educational, interpreted
dialect of Lisp that is often used in conjunction with a simulation of a
two-dimensional turtle. Our programming language has different features
than \emph{Logo}, does not support recursion as \emph{Logo} does, and
most importantly is integrated with ROS and thus able to be used with
three-dimensional simulators and actual robots.

\subsection{Paper Outline}

Section \ref{embodied} details how this work was inspired through embodied
improvisation for robot motion design, and the resulting design principles for
the tool.
Section
\ref{architecture-overview} provides an overview of the software design and
features, and some example programs. Section \ref{example-programs} shows some example programs and
interfaces. Section \ref{live-coding-interface} details the design choices that
were made for the live-coding interface. Section
\ref{domain-specific-language-design} describes some of the design decisions and
features of the high-level domain-specific language. Section
\ref{modelling-movement-in-haskell} details the modelling choices made in the
program which converts instructions in the domain-specific language to data
structures in Haskell and roshask, a client library for ROS.
Section \ref{interfacing-with-ros} details more about how ROS messages are
defined for specific robotic platforms. Finally, Section
\ref{conclusions-and-future-work} summarizes the paper and outlines directions
for future work, including user studies.

\emph{Improv} is open-source and available at
\url{https://github.com/alexandroid000/improv}. Please let us know if you try it
out!



\section{Prototyping Movement Design in Embodied Improvisation}\label{embodied}

In designing this tool, the authors were inspired by several of the principles
outlined in the `cognitive dimensions of notations' \cite{green1996usability}.
There are eleven `cognitive dimensions,' or design principles, that the authors
describe but several are especially relevant to this work, such as

\begin{itemize}
\item \emph{Closeness of mapping}: What `programming games' need to be learned?
\item \emph{Diffuseness}: How many symbols or graphic entities are required to express a meaning?
\item \emph{Error-proneness}: Does the design of the notation induce 'careless mistakes'?
\item \emph{Hard mental operations}: Are there places where the use needs to resort to  fingers or pencilled annotation to keep track of what's happening?
\item \emph{Progressive evaluation}: Can a partially-complete program be executed to
obtain feedback on `How am I doing'?
\end{itemize}

\section{Improv Architecture and Features}\label{architecture-overview}

\begin{figure}[h]
\centering
\includegraphics[width=8.00000cm]{/home/alli/common/figs/flowchart.pdf}
\caption{An illustration of how user input, written to a text file, is
converted into a ROS node which publishes messages to a simulator.
\label{flowchart}}
\end{figure}

The \emph{Improv} system consists of the following components:

\begin{itemize}
\item
  a live-coding interface, where the user writes a program in any text
  editor of their choosing. When they save changes to the file, they
  observe the resulting movement pattern on a simulated robot
\item
  a shell script which monitors the user's file for changes, at which
  point it resets the simulator, and executes a compiled Haskell program
  which interprets the user code and starts a corresponding ROS node
\item
  the ROS node, created with roshask \cite{cowley2011stream}, which sends messages to
  the simulator. Currently, only \texttt{Twist} messages can be created,
  which contain linear and rotational velocity information.
\item
  A simulator (or actual robot), which recieves ROS messages and
  executes movement on a robot platform. Currently, we have tested the
  system with:
  \begin{itemize}
  \item
    TurtleSim: a two dimensional simulator with limited physics, where
    velocity commands are nearly exactly executed on an animated turtle.
  \item
    Gazebo with a TurtleBot robot model: a three-dimensional simulator
    with more realistic physics, where velocity commands control
    simulated motors.
  \end{itemize}
\end{itemize}

See Figure \ref{flowchart} for a diagrammatic representation of
information flow in the system.


\subsection{Example Programs}\label{example-programs}

Figures \ref{gedit} and \ref{vim} show examples of the system in use with two
different text editors and two different simulators. Note that the choice of
editor and the choice of simulator are decoupled, and \emph{Improv} is
absolutely editor-agnostic, relying only on an operating-system level script
which monitors a text file for changes to execute the interpretation and
simulation process. \emph{Improv} is somewhat simulator-agnostic, although
currently it is only possible to control robots which use a certain ROS message
type for control (the Twist message, which sets desired linear and rotational
velocity).

\begin{figure}[h]
\centering
\includegraphics[width=8cm]{/home/alli/common/figs/improv_gedit_gazebo.png}
\caption{A program written in Gedit, a simple graphical text editor, with Gazebo and a simulated
Turtlebot.\label{gedit}}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=8cm]{/home/alli/common/figs/termturtle.png}
\caption{A program written in vim, a terminal-based text editor, with TurtleSim and two
simulated turtles.\label{vim}}
\end{figure}



\section{Domain-Specific Language
Design}\label{domain-specific-language-design}

Many domain-specific languages for robot programming exist; for example, a
review in 2016 identified 137 relevant publications 

"The closer the programming world is to the problem world, the easier the
problem-solving ought to be. Ideally, the problem entities in the user's task
domain could be mapped directly onto task-specific program entities, and
operations on those problem entities would likewise be mapped directly onto
program operations."


{\color{red} justify making another one... or just take this number out and add
other motivation}

The base type of the \emph{Improv} language is a movement. Movements are
discretized and can be combined with each other in various ways, forming
different movements. The precise way in which this is interpreted on a
robot platform is defined by the language's translation to Haskell and
the commands sent to ROS for the particular robot in question.

\begin{figure}
\centering
\begin{verbatim}
movement = prim
         | movement movement
         | transformer movement
         | [movement]
         | (movement)
         | movement || movement 

exp = rs $ movement
    | var = movement
\end{verbatim}
\caption{The grammar of Improv programs. \texttt{exp} represents top-level
expressions, which execute movements on robot(s), or store movements in
variables. \texttt{movement}s are converted into ROS message streams and can be
composed and grouped in multiple ways. {\color{red} run past Mattox, see if he
has an example I can emulate}}

\end{figure}

The terminals in \emph{Improv}, such as \texttt{forward} or
\texttt{right}, are mapped to streams of ROS messages. In our
implementation so far, we have mapped to the \texttt{Twist} ROS message,
which contains two three-dimensional vectors
representing the robot's linear and angular velocity. Controllers, which often
are included with commercial robots, are required to perform the low-level motor
control to acheive and maintain the desired velocities.

Here, we have simplified the language
by varying only three of these values, the robots \(x,y-\)velocity in
the plane and its angular velocity in the plane. Many ROS- and
Gazebo-integrated robots have available velocity controllers. We have
also discretized velocities, though users control velocity only relative
to other movements, by specifying their relative timing.

Movements are organized in time into units, where each unit is performed in one
``beat.'' The base timing of beats (units per minute) can be specified by the
user, and is only limited by the maximum publishing frequency of ROS and the
physical constraints of the robot platform.

Users can specify a series of commands such as \emph{move forward for
one beat, turn right for one beat, move forward for one beat} with the
command \texttt{forward right forward}. Movements separated by white
space will occur in different ``beats.''

The user can also use brackets to compress a sequence of movements into
one beat, such as \texttt{forward right forward}, which will
cause these three movements to happen in the same amount of time as the
first movement in the previous example. This syntax and behavior is directly 
inspired by \emph{TidalCycles}, which has a similar mechanism for grouping
sounds. In our implementation,
bracketing $n$ movements causes each movement to be performed $n$
times faster, but for $1/n$ times as long, so the movement has the
same extent but is performed faster.

Movements can also be performed in parallel, such as
\texttt{forward \textbar{}\textbar{} right}, which will cause the
robot to curve to the right as it moves forward. In our implementation,
velocities in parallel are simply added, so
\texttt{forward \textbar{}\textbar{} backward} would result in no
movement. A movement which is two movements in parallel will terminate
when the ``shorter'' movement ends, so the program
\texttt{(forward right) \textbar{}\textbar{} forward} will never turn
right (parenthesis are used to group movements without changing timing).

We have also implemented several transformations which map a function
over a movement. For example, \texttt{repeat} takes an integer and a
movement as arguments and causes that movement to repeat for the
specified number of times.

In space, we have \texttt{reflect}, which takes a plane and a movement
as arguments and returns the reflected movement
(\texttt{reflect\ YZ\ right} yields \texttt{left}, where the \texttt{YZ}
plane is body-centered and would be the saggital plane on a biological
organism). For transforming movements in time, \texttt{reverse} is a
unary operator which will reverse the order of a series of movements:
\texttt{reverse\ (forward\ right\ left)} is equivalent to
\texttt{left\ right\ forward}. To reverse the trajectory itself, we use
\texttt{retrograde}, which uses spatial reflections and reverses time;
for example, \texttt{retrograde\ (forward\ right\ left)} is equivalent
to \texttt{right\ left\ backward}. Both \texttt{retrograde} and
\texttt{reverse} are their own inverses: applying them twice returns the
original movement, as would be expected.

While we have only implemented these combinators for simple and very
symmetric mobile robots, one could imagine making more complicated types
of symmetry for other robot platforms. We have included a typeclass
\texttt{Symmetric\ a} which is defined by a function
\texttt{refl\ ::\ Plane\ -\textgreater{}\ a\ -\textgreater{}\ a} which
is parameterized by a body type \texttt{a}. By defining this function
once for a new robot platform, detailing all the different symmetries of
the body, the functionality of these spatial transformers can be
extended to new platforms.

\subsection{Multiple Robots}\label{multiple-robots}

The \emph{Improv} system has the capapbility to control multiple robots
at once, using a syntax which mirrors how \emph{TidalCycles} allows for
multiple tracks to be composed simultaneously. Each robot is given a
unique name in the shell script which launches ROS and the \emph{Improv}
system, and this is also where the initial location of each robot is
specified. Then, in the user's program, they specify which movement
sequence should be associated with each robot. For example, to make
robot \texttt{r1} move forward and robot \texttt{r2} move backward, the
user would write

\begin{verbatim}
r1 $ forward
r2 $ backward
\end{verbatim}

This syntax, along with assigning movements to variables, can make it easy to
specify relationships between how different robots are moving, such as

\begin{verbatim}
x = left right [forward right]
r1 $ x
r2 $ retrograde x
\end{verbatim}


which would cause robot \texttt{r2} to perform the same movement as
robot \texttt{r1}, but in retrograde. It is also possible to command two robots
to do the same movement with a program such as

\begin{verbatim}
r1 r2 $ forward backward
\end{verbatim}

As \emph{Improv} is extended to other platforms in the future, this could be an
interesting mechanism for studying how the same high-level choreographic
commands are perceived when executed on different platforms with different
interpretations of the commands.

\subsection{Modelling Movement in
Haskell}\label{modelling-movement-in-haskell}

{\color{red}add motivation: choregraphic operations, technologies. source to
cite? Labanotation? Really I learned this stuff in Catie's class. Can probably
just cite that and arXiv paper?}

Programs in the \emph{Improv} DSL are interpreted by a compiled Haskell
program into an ADT we call a \texttt{Dance}, which can be thought of as
a tree that holds all movement primitives (the terminals in the
\emph{Improv} language, such as \texttt{forward}). The operators of the
type encode the parallel/series structure of the user's program. To
execute a \texttt{Dance} as a series of ROS messages, we must flatten
the tree while maintaining this relative timing information, which will
be discussed in Section \ref{relative-timing}.

\texttt{Dance}s are defined as

\begin{verbatim}
data Dance b = Prim Action Mult b
             | Rest Mult
             | Skip
             | Dance b :+: Dance b
             | Dance b :||: Dance b
\end{verbatim}

where \texttt{Prim} is a motion primitive type, holding the
\texttt{Action} (direction and spatial extent of the movement),
\texttt{Mult} which stores timing information, and \texttt{b}, a parameterized type describing the
part of the robot to move. \texttt{Rest} indicates that the robot part
is not moving for some period of time (and is a terminal in the
\emph{Improv} language). \texttt{Skip} is the identity dance, having no
effect on the robot for no time duration, and is necessary for the
monoidal structure of the parallel (\texttt{:\textbar{}\textbar{}:}) and
series (\texttt{:+:}) operators.

\subsection{\texorpdfstring{Algebraic Structure of
\texttt{Dance}s}{Algebraic Structure of Dances}}\label{algebraic-structure-of-dances}

{\color{red} maybe nix this section - or make less pretentious, more clear
benefits}

This algebraic structure helps enforce the timing behavior that we
expect; namely, associativity. If \texttt{d1}, \texttt{d2}, and
\texttt{d3} are all \texttt{Dance}s (with an arbitrary number and
structure of movement primitives in each), then the order that they are
sequenced together shouldn't matter:

\begin{verbatim}
(d1 :+: d2) :+: d3 = d1 :+: (d2 :+: d3)
\end{verbatim}

And similarly, if they are all three in parallel, arbitrary groupings
should not change the meaning of the program. This is exactly the
behavior that the algebraic objects \emph{monoids} have, namely
associativity and an identity element. See \cite{yorgey2012monoids} for a much more
detailed discussion on the usefulness of monoids in modelling and
programming languages, in the context of \emph{Diagrams}, a Haskell DSL
for creating vector graphics.

We can create monoid instances in Haskell for these operators on
\texttt{Dance} data types, which allow for lists of \texttt{Dance}s
(read in by the parser as all elements between square brackets or
separated by the \texttt{\textbar{}\textbar{}} operator) to be combined
in sequence or parallel. The functions for doing so, \texttt{seqL} and
\texttt{parL}, have the type
\texttt{(Parts\ a)\ =\textgreater{}\ {[}Dance\ a{]}\ -\textgreater{}\ Dance\ a}:
they combine movements using the monoidal operator.


\subsection{Relative Timing}\label{relative-timing}

As programs are parsed, we must enforce the timing semantics - movements
inside square brackets, such as \texttt{{[}forward\ right\ forward{]}},
must occur within one ``beat.'' To accomplish this, the parser reads in
the elements inside brackets as a list of \texttt{Dance}s.

Then we call a function \texttt{seqL} which uses the length of the
initial list to determine how much to speed up each individual dance
before composing the movements. This is accomplished with a function
\texttt{changeTiming} which takes a multiplier \texttt{m} and a
\texttt{Dance}, and propagates the multiplier through the \texttt{Dance}
recursively. This allows for nested sequential movements: for example,
the program \texttt{{[}forward\ {[}left\ left{]}\ forward{]}} would
translate to the \texttt{Dance}

\begin{verbatim}
Prim (A f 3 r) :+: Prim (A l 6 r) :+: 
Prim (A l 6 r) :+: Prim (A f 3 r)
\end{verbatim}

where \texttt{f} is the \texttt{Action} corresponding to
\texttt{forward}, \texttt{l} is the \texttt{Action} corresponding to
\texttt{left}, and \texttt{r} is the robot body. Note that the two
primitives inside the nested brackets have \texttt{Mult}s of 6, since
they must occur six times as fast as normal to allow the whole movement
to occur in one ``beat.''

\section{Interfacing with ROS}\label{interfacing-with-ros}

{\color{red}benefits of interfacing with ROS}

\subsection{Live-Coding Interface}\label{live-coding-interface}

One important design decision for developers of interactive text-based
programming tools is whether to tie their tool to a specific editor. For
example, the Algorave live-coding tool TidalCycles was originally
developed for Emacs, a powerful editor which has a notoriously steep
learning curve {\color{red} cite}. Many people prefer to use simpler editors, so new
live-coding plug-ins have been developed for editors such as Atom and
Sublime Text. This editor-based approach has advantages, such as a large
degree of customizability and extensibility using the features of the
editors. However, it also introduces challenges such as maintaining
feature parity between editors, as well as the up-front investment
needed to interface with new editors. In our case, we are developing a
tool that should be usable by artists, children, and programming
novices, as well as experienced roboticists. Thus, we wish to allow
users flexibility to use their editor of preference.

To accomplish this, instead of creating an interface for each desired
editor, we use a shell script which monitors the file that the user is
editing for changes. Every time the user saves changes to the file, the
program detects a change, interprets the user's new program, and resets
the simulator and ROS node. This design choice circumvents the need to
interface with specific editors. Additionally, many editors have
keyboard shortcuts for saving files. Thus, executing programs
contributes minimally to the overall workload of using the system,
especially when compared to the many steps required to test changes to
traditional ROS programs. The delay between saving the file and observing the
changes in the simulator is very short - while we have not done a formal timing
analysis, the delay is a fraction of a second and not noticeably longer than the
time it takes to shift attention from the text editor to the simulator.

\emph{Roshask} is a client library for ROS, written in Haskell
\cite{cowley2011stream}. It treats streams of values (such as those published
and subscribed to by ROS nodes) as first class values, which allows for them to
be combined and transformed in more natural ways than traditional ROS client
libraries. For example, when we put `Dance`s in parallel, we wish to combine two
list of motion commands with some function for parallel execution - whether this
is averaging commands which affect the same body part, or additively combining
them, or whatever interpretation the designer wishes for a specific robot
platform. In Haskell, this is accomplished easily with the
`zipWith` function, which takes two lists and a function for combining values in
those lists. Roshask extends this type of expressivity to the combination and
transformation of ROS message streams.

To integrate a robot with \emph{Improv}, one must
specify how to convert the \texttt{Dance} data structure to a list of ROS
messages. For example, for a non-articulated symmetric mobile robot (such as a Roomba or
TurtleBot), this is accomplished by two functions: \texttt{moveBase} and
\texttt{danceToMsg}. Since the robot has only one body part, \texttt{moveBase}
takes an \texttt{Action} (direction and extent of movement) and converts it to a
single ROS velocity command (which sets the desired linear and rotational
velocity in the plane). Since our discretization of movements is relational (for
example, you can have \texttt{Full}, \texttt{Half}, and \texttt{Quarter} extent,
and directions are related through symmetries), only a small number of these
translations from \texttt{Action}s to velocities need to be explicitly defined
and the rest can be derived through their relations. For example,
\texttt{moveBase (A dir Half)} is defined as \texttt{fmap (*2) (moveBase (A dir
Quarter))},
where \texttt{fmap} maps the function \texttt{*2} over the values in the velocity
command returned by \texttt{moveBase (A dir Quarter)}. This encodes the relationship
that a \texttt{Half} extent is twice as far as a \texttt{Quarter}, thus the
robot must move twice as fast in the same direction to travel twice the distance
in the same amount of time.

Once this conversion (from a `Dance` data structure to a list of ROS messages)
has been completed, the list of ROS messages is given as an argument to a ROS
node defined in roshask. This node publishes the commands over the ROS network.
Even if multiple robots are controlled, the system still only uses one ROS node
which publishes to multiple topics. Work is ongoing on whether to extend the
system to control multiple ROS nodes, and if so, how best to implement this
feature.

With all of these implementation details, we would like to emphasize
that the design decisions for how \emph{Improv} programs are realized on
robot platforms are relatively arbitrary and a single robot could have a
multitude of different implementations. ``It is not technological
constraints that hold us back from using technology in new ways;
technology changes at a tremendous rate. Our willingness to explore
beyond the constraints of our imagination has the greatest effect''
\cite{schiphorst}.


\section{Conclusions and Future
Work}\label{conclusions-and-future-work}

This paper has presented a working implementation of a small domain-specific
language which is interpreted and executed as a stream of ROS messages published
by a ROS node. Due to fast interpretation of the language and a program which
monitors a user's program file for changes, this system allows for a very fast
feedback loop while programming robots. We hope that this short feedback loop,
along with a programming language which models movement directly instead of the
abstract state control flow typical of robotics languages, would decrease the
cognitive load associated with robot programming. We aim to make the creative
development of robot motion patterns faster, easier, and more accessible to a
broader swath of potential users.

Future work will include systematic studies of people's qualitative assesment of
the usability of the system, as well as quantitative measures on how quickly
people iterate on programs in the *Improv* language and how much the robot moves
as a result. As far as we know, no similar usability studies have been performed
on the more mainstream C++ and Python ROS clients. We plan to include a range of
participants in our study, including people with limited programming experience
and no ROS experience, as well as people familiar with ROS.

The main limitation of \emph{Improv}, as compared to other live-coding tools for
ROS, is that it includes no features for controlling the robots based on sensor
observations or interactions with the environment.

Another limitation of \emph{Improv} is the complexity of defining the conversion
from `Dance` data structures to ROS messages, especially for robots with many
body parts and degrees of freedom. Additionally, we have only implemented the
system for robots which have velocity controllers, and several aspects of the
movement transformation model depend on this assumption. For some robots,
especially commercially available models, position-based controllers may be the
only option available.

{\color{red}add uplifting good things, future work to address these limitatiions}

\section{Acknowledgements}

This work is partially funded by DARPA grant \#D16AP00001.

{\color{red} Alli grant? Should ask Steve}

\bibliographystyle{ACM-Reference-Format}
\bibliography{/home/alli/common/refs}

\end{document}
