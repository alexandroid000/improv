Usability Analysis of Visual Programming Environments: A 'Cognitive Dimensions' Framework - Green Petre - 1996
==============================================================================================================

Abstract
--------

The cognitive dimensions framework is a broad-brush evaluation technique for
interactive devices and for non-interactive notations. It sets out a small
vocabulary of terms designed to capture the cognitively-relevant aspects of
structure, and shows how they can be traded off against each other. The purpose
of this paper is to propose the framework as an evaluation technique for visual
programming environments. We apply it to two commercially-available dataflow
languages (with further examples from other systems) and conclude that it is
effective and insightful; other HCI-based evaluation techniques focus on
different aspects and would make good complements. Insofar as the examples we
used are representative, current VPLs are successful in achieving a good
'closeness of match,' but designers need to consider the 'viscosity' (resistance
to local change) and the 'secondary notation' (possibility of conveying extra
meaning by choice of layout, colour, etc).

Summary
-------

Two maxims on notational structure effects:

1. Every notation highlights some kinds of information at the expense of
obscuring other kinds.
2. When seeking information, there must be a cognitive fit between the mental
representations and the external representation.

The cognitive dimensions:
1. *Abstraction gradient*: What are the minimum and maximum levels of
abstraction? Can fragments be encapsulated?
2. *Closeness of mapping*: What 'programming games' need to be learned?
3. *Consistency*: When some of the language has been learnt, how much of the
rest can be inferred?
4. *Diffuseness*: How many symbols or graphic entities are required to express a
meaning?
5. *Error-proneness*: Does the design of the notation induce 'careless
mistakes'?
6. *Hard mental operations*: Are there places where the use needs to resort to
fingers or pencilled annotation to keep track of what's happening?
7. *Hidden dependencies*: Is every dependency overtly indicated in both
directions? Is the indication perceptual or only symbolic?
8. *Premature commitment*: Do programmers have to make decisions before they
have the information they need?
9. *Progressive evaluation*: Can a partially-complete program be executed to
obtain feedback on 'How am I doing'?
10. *Role-expressiveness*: Can the reader see how each component of a program
relates to the whole?
11. *Secondary notation* Can programmers use layout, colour, other cues to
convey extra meaning, above and beyond the 'official' semantics of the language?
12. *Viscosity*: How much effort is required to perform a single change?
13. *Visibility*: Is every part of the code simultaneously visible (assuming a
large enough display), or is it at least possible to juxtapose any two parts
side-by-side at will? If the code is dispersed, is it at least possible to know
in what order to read it?

"The closer the programming world is to the problem world, the easier the
problem-solving ought to be. Ideally, the problem entities in the user's task
domain could be mapped directly onto task-specific program entities, and
operations on those problem entities would likewise be mapped directly onto
program operations."

---
references:
- id: green1996usability
  type: article-journal
  author:
  - family: Green
    given: Thomas R. G.
  - family: Petre
    given: Marian
  issued:
  - year: '1996'
  title: 'Usability analysis of visual programming environments: A ‘cognitive dimensions’
    framework'
  title-short: Usability analysis of visual programming environments
  container-title: Journal of Visual Languages & Computing
  publisher: Elsevier
  page: '131-174'
  volume: '7'
  issue: '2'
...

